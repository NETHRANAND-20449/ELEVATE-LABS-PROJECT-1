# scanner/vulnerability_tests.py - Enhanced Version with Better XSS Detection

import requests
from bs4 import BeautifulSoup
import time
import re
import html
import random
import string
from typing import List, Dict
import urllib.parse

class VulnerabilityTester:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'VulnScanner/1.0 (Security Testing Tool)'
        })
        self.vulnerabilities = []
        
        # SQL Injection Payloads (keeping original)
        self.sqli_payloads = [
            "'",
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin'--",
            "admin'/*",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0--"
        ]
        
        # SQL Error patterns (keeping original)
        self.sql_errors = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"PostgreSQL.*ERROR",
            r"Warning.*pg_.*",
            r"valid PostgreSQL result",
            r"ORA-[0-9]{4,5}",
            r"Oracle error",
            r"Microsoft OLE DB Provider for ODBC Drivers error",
            r"Unclosed quotation mark after the character string",
            r"SQLite.*error"
        ]
    
    def _generate_unique_marker(self) -> str:
        """Generate a unique marker for XSS testing"""
        return 'XSS_' + ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
    
    def test_xss(self, form_data: Dict) -> List[Dict]:
        """Enhanced XSS vulnerability testing with better detection logic"""
        vulnerabilities = []
        
        # Enhanced XSS payloads with unique markers
        base_payloads = [
            {
                'template': '<script>alert("MARKER")</script>',
                'type': 'script_tag',
                'context': 'html'
            },
            {
                'template': '<img src=x onerror=alert("MARKER")>',
                'type': 'img_onerror',
                'context': 'html'
            },
            {
                'template': '<svg onload=alert("MARKER")>',
                'type': 'svg_onload',
                'context': 'html'
            },
            {
                'template': 'javascript:alert("MARKER")',
                'type': 'javascript_protocol',
                'context': 'attribute'
            },
            {
                'template': '"><script>alert("MARKER")</script>',
                'type': 'attribute_break',
                'context': 'attribute'
            },
            {
                'template': "';alert('MARKER');//",
                'type': 'js_injection',
                'context': 'javascript'
            }
        ]
        
        # Test each input field separately
        for input_field in form_data['inputs']:
            if input_field['type'] in ['hidden', 'submit', 'button']:
                continue
                
            field_name = input_field['name']
            if not field_name:
                continue
                
            print(f"  Testing XSS in field: {field_name}")
            
            for payload_template in base_payloads:
                try:
                    # Generate unique marker for this test
                    marker = self._generate_unique_marker()
                    payload = payload_template['template'].replace('MARKER', marker)
                    
                    # Prepare form data - only inject payload into current field
                    data = {}
                    for field in form_data['inputs']:
                        if field['name'] == field_name:
                            data[field['name']] = payload
                        elif field['type'] not in ['hidden', 'submit', 'button']:
                            # Use safe default values for other fields
                            data[field['name']] = 'test'
                        else:
                            data[field['name']] = field['value']
                    
                    # Submit form
                    if form_data['method'] == 'post':
                        response = self.session.post(form_data['action'], data=data, timeout=10)
                    else:
                        response = self.session.get(form_data['action'], params=data, timeout=10)
                    
                    # Enhanced XSS detection
                    xss_detected, detection_method, context_info = self._detect_xss_in_response(
                        response.text, 
                        payload, 
                        marker,
                        payload_template['type']
                    )
                    
                    if xss_detected and not self._is_false_positive(response.text, payload, marker):
                        vulnerability = {
                            'type': 'XSS',
                            'severity': self._get_xss_severity(payload_template['type']),
                            'url': form_data['action'],
                            'payload': payload,
                            'method': form_data['method'],
                            'parameter': field_name,
                            'evidence': f"XSS detected via {detection_method}. Unique marker '{marker}' found in dangerous context.",
                            'description': f'Cross-Site Scripting ({payload_template["type"]}) vulnerability detected in parameter "{field_name}"',
                            'xss_type': payload_template['type'],
                            'context': context_info
                        }
                        vulnerabilities.append(vulnerability)
                        print(f"    âœ“ XSS found: {payload_template['type']} in field '{field_name}'")
                        break  # Found XSS in this field, move to next field
                        
                except Exception as e:
                    print(f"    Error testing XSS on field '{field_name}': {str(e)}")
                    continue
        
        return vulnerabilities
    
    def _detect_xss_in_response(self, response_text: str, payload: str, marker: str, payload_type: str) -> tuple:
        """Enhanced XSS detection with multiple methods"""
        
        # Method 1: Check for unique marker in dangerous contexts only
        if marker not in response_text:
            return False, "marker_not_found", {}
        
        # Method 2: Parse HTML and check contexts
        try:
            soup = BeautifulSoup(response_text, 'html.parser')
            
            # Check for marker in script tags
            for script in soup.find_all('script'):
                if script.string and marker in script.string:
                    return True, "script_tag_content", {"tag": "script", "content": script.string[:100]}
            
            # Check for marker in dangerous attributes
            dangerous_attrs = ['onclick', 'onload', 'onerror', 'onmouseover', 'onfocus', 'onblur', 'onchange']
            for tag in soup.find_all():
                for attr in dangerous_attrs:
                    attr_value = tag.get(attr)
                    if attr_value and marker in str(attr_value):
                        return True, f"event_handler_{attr}", {"tag": tag.name, "attribute": attr}
            
            # Check for marker in href with javascript: protocol
            for tag in soup.find_all(['a', 'area']):
                href = tag.get('href')
                if href and marker in href and href.strip().lower().startswith('javascript:'):
                    return True, "javascript_protocol", {"tag": tag.name, "href": href[:50]}
            
            # Check for marker in src attributes of dangerous tags
            dangerous_src_tags = ['img', 'iframe', 'script', 'object', 'embed']
            for tag_name in dangerous_src_tags:
                for tag in soup.find_all(tag_name):
                    src = tag.get('src')
                    if src and marker in src:
                        return True, f"src_attribute_{tag_name}", {"tag": tag_name, "src": src[:50]}
        
        except Exception as e:
            print(f"Error parsing HTML: {e}")
        
        # Method 3: Regex-based detection for contexts BeautifulSoup might miss
        dangerous_patterns = [
            # Script tag content
            (rf'<script[^>]*>[^<]*{re.escape(marker)}[^<]*</script>', "script_content_regex"),
            # Event handlers
            (rf'on\w+\s*=\s*["\'][^"\']*{re.escape(marker)}[^"\']*["\']', "event_handler_regex"),
            # JavaScript protocol
            (rf'javascript:[^"\'>\s]*{re.escape(marker)}[^"\'>\s]*', "javascript_protocol_regex"),
            # Style attribute
            (rf'style\s*=\s*["\'][^"\']*{re.escape(marker)}[^"\']*["\']', "style_attribute"),
        ]
        
        for pattern, detection_type in dangerous_patterns:
            if re.search(pattern, response_text, re.IGNORECASE | re.DOTALL):
                return True, detection_type, {"pattern": pattern}
        
        # Method 4: Check if marker appears unescaped in HTML tag context
        # This is more dangerous than just appearing in text content
        tag_patterns = [
            rf'<[^>]*{re.escape(marker)}[^>]*>',  # In tag attributes
            rf'<{re.escape(marker)}[^>]*>',       # As tag name (unlikely but possible)
        ]
        
        for pattern in tag_patterns:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True, "unescaped_in_html_tag", {"pattern": pattern}
        
        return False, "no_dangerous_context", {}
    
    def _is_false_positive(self, response_text: str, payload: str, marker: str) -> bool:
        """Check for common false positive scenarios"""
        
        # Check if marker appears only in error messages or safe contexts
        safe_contexts = [
            # Error messages
            rf'error[^<>]*{re.escape(marker)}',
            rf'exception[^<>]*{re.escape(marker)}',
            rf'warning[^<>]*{re.escape(marker)}',
            # Debug output
            rf'debug[^<>]*{re.escape(marker)}',
            rf'log[^<>]*{re.escape(marker)}',
            # Safe HTML contexts
            rf'<pre[^>]*>[^<]*{re.escape(marker)}[^<]*</pre>',
            rf'<code[^>]*>[^<]*{re.escape(marker)}[^<]*</code>',
            rf'<textarea[^>]*>[^<]*{re.escape(marker)}[^<]*</textarea>',
            # HTML escaped
            rf'{re.escape(html.escape(payload))}',
            # URL encoded
            rf'{re.escape(urllib.parse.quote(payload))}',
            # Just plain text in paragraph or div
            rf'<(?:p|div)[^>]*>[^<]*{re.escape(marker)}[^<]*</(?:p|div)>',
        ]
        
        for pattern in safe_contexts:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True
        
        # Check if it's just echoed back in a form field value
        form_value_pattern = rf'<input[^>]*value\s*=\s*["\'][^"\']*{re.escape(marker)}[^"\']*["\'][^>]*>'
        if re.search(form_value_pattern, response_text, re.IGNORECASE):
            # This could still be XSS if it's not properly escaped, so check further
            soup = BeautifulSoup(response_text, 'html.parser')
            for input_tag in soup.find_all('input'):
                value = input_tag.get('value')
                if value and marker in value:
                    # If the value contains unescaped quotes or script-like content, it's still XSS
                    if '"' in payload or "'" in payload or '<' in payload:
                        return False  # Still potentially XSS
                    return True  # Just echoed back safely
        
        return False
    
    def _get_xss_severity(self, xss_type: str) -> str:
        """Determine XSS severity based on type"""
        high_severity = ['script_tag', 'svg_onload', 'img_onerror']
        medium_severity = ['javascript_protocol', 'js_injection', 'attribute_break']
        
        if xss_type in high_severity:
            return 'High'
        elif xss_type in medium_severity:
            return 'Medium'
        else:
            return 'Low'
    
    def test_sql_injection(self, form_data: Dict) -> List[Dict]:
        """Test for SQL Injection vulnerabilities - keeping original logic"""
        vulnerabilities = []
        
        for payload in self.sqli_payloads:
            try:
                # Prepare form data
                data = {}
                for input_field in form_data['inputs']:
                    if input_field['type'] not in ['hidden', 'submit', 'button']:
                        data[input_field['name']] = payload
                    else:
                        data[input_field['name']] = input_field['value']
                
                # Submit form and measure response time
                start_time = time.time()
                
                if form_data['method'] == 'post':
                    response = self.session.post(form_data['action'], data=data, timeout=10)
                else:
                    response = self.session.get(form_data['action'], params=data, timeout=10)
                
                response_time = time.time() - start_time
                
                # Check for SQL errors
                sql_error_found = False
                for error_pattern in self.sql_errors:
                    if re.search(error_pattern, response.text, re.IGNORECASE):
                        sql_error_found = True
                        break
                
                # Check for time-based SQL injection (response time > 5 seconds)
                time_based_sqli = response_time > 5
                
                if sql_error_found or time_based_sqli:
                    vulnerability = {
                        'type': 'SQL Injection',
                        'severity': 'Critical',
                        'url': form_data['action'],
                        'payload': payload,
                        'method': form_data['method'],
                        'parameter': list(data.keys()),
                        'evidence': 'SQL error detected' if sql_error_found else f'Time delay detected: {response_time:.2f}s',
                        'description': 'SQL Injection vulnerability detected'
                    }
                    vulnerabilities.append(vulnerability)
                    print(f"SQLi found: {form_data['action']} with payload: {payload}")
                    break  # Found SQLi, no need to test more payloads
                    
            except Exception as e:
                print(f"Error testing SQLi on {form_data['action']}: {str(e)}")
                continue
        
        return vulnerabilities
    
    def test_csrf(self, form_data: Dict) -> List[Dict]:
        """Test for CSRF vulnerabilities - keeping original logic"""
        vulnerabilities = []
        
        # Check if form has CSRF token
        has_csrf_token = False
        csrf_fields = ['csrf_token', 'csrfmiddlewaretoken', '_token', 'authenticity_token']
        
        for input_field in form_data['inputs']:
            if any(csrf_field in input_field['name'].lower() for csrf_field in csrf_fields):
                has_csrf_token = True
                break
        
        if not has_csrf_token and form_data['method'] == 'post':
            vulnerability = {
                'type': 'CSRF',
                'severity': 'Medium',
                'url': form_data['action'],
                'payload': 'N/A',
                'method': form_data['method'],
                'parameter': 'Form lacks CSRF protection',
                'evidence': 'No CSRF token found in form',
                'description': 'Cross-Site Request Forgery (CSRF) vulnerability detected'
            }
            vulnerabilities.append(vulnerability)
            print(f"CSRF vulnerability found: {form_data['action']}")
        
        return vulnerabilities
    
    def check_security_headers(self, url: str) -> List[Dict]:
        """Check for missing security headers - keeping original logic"""
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-XSS-Protection': 'XSS protection header missing',
                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                'Strict-Transport-Security': 'HTTPS enforcement missing',
                'Content-Security-Policy': 'Content Security Policy missing'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vulnerability = {
                        'type': 'Security Headers',
                        'severity': 'Low',
                        'url': url,
                        'payload': 'N/A',
                        'method': 'GET',
                        'parameter': header,
                        'evidence': f'Missing {header} header',
                        'description': description
                    }
                    vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"Error checking security headers for {url}: {str(e)}")
        
        return vulnerabilities
    
    def run_all_tests(self, crawl_data: Dict) -> List[Dict]:
        """Run all vulnerability tests"""
        print("Starting vulnerability tests...")
        all_vulnerabilities = []
        
        # Test each form for vulnerabilities
        for i, form in enumerate(crawl_data['forms'], 1):
            print(f"Testing form {i}/{len(crawl_data['forms'])}: {form['action']}")
            
            # Test XSS
            print("  Testing for XSS...")
            xss_vulns = self.test_xss(form)
            all_vulnerabilities.extend(xss_vulns)
            
            # Test SQL Injection
            print("  Testing for SQL Injection...")
            sqli_vulns = self.test_sql_injection(form)
            all_vulnerabilities.extend(sqli_vulns)
            
            # Test CSRF
            print("  Testing for CSRF...")
            csrf_vulns = self.test_csrf(form)
            all_vulnerabilities.extend(csrf_vulns)
        
        # Check security headers for each visited URL
        print("Checking security headers...")
        for url in crawl_data['visited_urls']:
            header_vulns = self.check_security_headers(url)
            all_vulnerabilities.extend(header_vulns)
        
        print(f"Vulnerability testing completed. Found {len(all_vulnerabilities)} issues.")
        return all_vulnerabilities
